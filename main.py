"""
FastAPI app exposing endpoints to access manufacturer coupon data.

Endpoints:
- GET /coupon?drug_name=...         -> retrieve a single branded drug coupon (first match)
- GET /coupons                      -> list coupons with pagination and optional drug_name filter

Features:
- Standardized JSON responses
- Simple in-memory rate limiting (per-client IP)
- Logging and monitoring endpoints
- Swagger/OpenAPI docs auto-generated by FastAPI
"""
from fastapi import FastAPI, HTTPException, Request, Security
from fastapi.responses import JSONResponse
from fastapi.security.api_key import APIKeyHeader
from pydantic import BaseModel
from typing import Any, Optional
import time
import logging
from collections import defaultdict

from db import get_coupon_by_drug, list_coupons, count_coupons
from auth_db import ensure_db_initialized, get_key_info

# ensure API keys DB exists and has at least one seed key
ensure_db_initialized(seed=True)

app = FastAPI(title="GoodRx Coupons API", version="0.1.0")

# Setup basic logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger("goodrx_api")

# OpenAPI/Swagger: API Key header that appears in the Authorize dialog
api_key_header = APIKeyHeader(name="x-api-key", auto_error=False)


# Simple in-memory rate limiter (token bucket) - stability-only, not a security layer
RATE_LIMIT = 60  # requests
RATE_PERIOD = 60  # seconds
_buckets = defaultdict(lambda: {"tokens": RATE_LIMIT, "last": time.time()})


def _get_client_key(request: Request) -> str:
    # Use client host (X-Forwarded-For not trusted here). For deployments behind proxies, consider using forwarded headers.
    client = request.client.host if request.client else "unknown"
    return client


# API key middleware (runs before rate limiter)
@app.middleware("http")
async def api_key_middleware(request: Request, call_next):
    # Allow unauthenticated access to the interactive docs and OpenAPI json
    public_prefixes = ("/docs", "/openapi.json", "/redoc", "/favicon.ico")
    if request.url.path.startswith(public_prefixes) or request.method == "OPTIONS":
        return await call_next(request)

    key = request.headers.get("x-api-key") or request.headers.get("X-API-Key")
    if not key:
        logger.warning("Missing API key from %s", _get_client_key(request))
        return JSONResponse(status_code=401, content={"success": False, "code": 401, "message": "Missing API key"})

    info = get_key_info(key)
    if not info:
        logger.warning("Invalid API key from %s", _get_client_key(request))
        return JSONResponse(status_code=401, content={"success": False, "code": 401, "message": "Invalid API key"})

    # Key is valid; you can access info['client_name'] and info['rate_limit'] here
    request.state.client_name = info.get('client_name')
    request.state.api_key = key
    return await call_next(request)


def _allow_request(request: Request) -> bool:
    key = _get_client_key(request)
    bucket = _buckets[key]
    now = time.time()
    # refill tokens
    elapsed = now - bucket["last"]
    refill = int(elapsed / RATE_PERIOD) * RATE_LIMIT
    if refill > 0:
        bucket["tokens"] = min(RATE_LIMIT, bucket["tokens"] + refill)
        bucket["last"] = now

    if bucket["tokens"] > 0:
        bucket["tokens"] -= 1
        return True
    return False


class StandardResponse(BaseModel):
    success: bool
    code: int
    message: Optional[str] = None
    data: Optional[Any] = None


@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    if not _allow_request(request):
        logger.warning("Rate limit exceeded for %s", _get_client_key(request))
        return JSONResponse(status_code=429, content={"success": False, "code": 429, "message": "Rate limit exceeded"})
    # simple request logging
    logger.info("%s %s from %s", request.method, request.url.path, _get_client_key(request))
    start = time.time()
    response = await call_next(request)
    duration = time.time() - start
    logger.info("Processed %s %s in %.3fs", request.method, request.url.path, duration)
    return response


# Dependency used by OpenAPI to show the header in the docs and validate the key
def get_api_key(api_key: str = Security(api_key_header)) -> str:
    """Validate the provided API key against the api_keys.db and return it on success.

    This function is used as a dependency so OpenAPI/Swagger shows the x-api-key field in the Authorize dialog.
    """
    if not api_key:
        raise HTTPException(status_code=401, detail="Invalid or missing API key")
    info = get_key_info(api_key)
    if not info:
        raise HTTPException(status_code=401, detail="Invalid or missing API key")
    return api_key


@app.get("/coupon", response_model=StandardResponse)
def read_coupon(drug_name: str, api_key: str = Security(get_api_key)) -> Any:
    """Return the first matching coupon for the provided branded drug_name.

    Query param:
    - drug_name: the branded drug name to look up
    """
    try:
        row = get_coupon_by_drug(drug_name)
    except FileNotFoundError as e:
        logger.exception("DB file missing")
        raise HTTPException(status_code=500, detail=str(e))

    if not row:
        # 404 with structured response
        return StandardResponse(success=False, code=404, message="Coupon not found", data=None)

    return StandardResponse(success=True, code=200, message="OK", data=row)


@app.get("/coupons", response_model=StandardResponse)
def list_coupons_endpoint(page: int = 1, per_page: int = 50, api_key: str = Security(get_api_key)):
    """List coupons with pagination. No drug_name filter by default.

    - page: 1-based page number
    - per_page: items per page (max 500)
    """
    per_page = min(max(1, per_page), 500)
    page = max(1, page)
    offset = (page - 1) * per_page
    try:
        items = list_coupons(limit=per_page, offset=offset)
        total = count_coupons()
    except FileNotFoundError as e:
        logger.exception("DB missing")
        raise HTTPException(status_code=500, detail=str(e))

    meta = {"page": page, "per_page": per_page, "total": total}
    return StandardResponse(success=True, code=200, message="OK", data={"items": items, "meta": meta})
